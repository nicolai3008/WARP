/******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Monochromator_bent_simple
*
* %I
* Written by: Nicolai Lindaa Amin <s194113@dtu.dk>
* Based on more complicated Monochromator_bent by Daniel Lomholt Christensen
* implemented for PSI WARP instrument proposal. Once Monochromator_bent is done, this
* component should be replaced as this is a simple budget version of that component.
* 
*
* Date: 15 July 2024
* Origin: PSI, Paul Schreerer Institut, Villigen, Switzerland
*
* A perfect bent crystal monochromator.
*
* %D
* This monochromator is a single monochromatic thick crystal. 
* The crystal is bent, so that it follows a curve on a cylinder of radius R_C.
* The monochromator lies along the z plane, so when a diffraction angle of theta 
* is desired, it should just be inserted in the ROTATED parameter around
* the y-axis.
* Instruments that showcase the use of this component is the 
* "Test_monochromator_bent.instr", and the "PSI_WARP.instr" under the examples folder.
* WARP showcases its complex use in a real instrument, while Test_monochromator_bent
* makes a simple show of its capabilities.
*
*
* %P
* INPUT PARAMETERS:
*
* zwidth [m]                   			Width of each lamella without bending.
* yheight [m]                			Height of each lamella without bending.
* xthickness [m]             			Thickness of each lamella without bending.
* radius_x [m]               			Radius of the circle the monochromator bends on in the plane.
* plane_of_reflection ["Si111"] 		The plane of reflection from the material. The list of possible reflections can 
* 										can be seen in the source code.
* angle_to_cut_horizontal [degrees]  	Angle between cut and normal of crystal slab, horizontally
* angle_to_cut_vertical [degrees] 		Angle between cut and normal of crystal slab, vertically
* mosaicity [arc minutes]               Gaussian mosaicity of the crystal. 
* domainthickness [micro meter]			Thickness of the crystal domains.
* verbose: [0]							Verbosity of the monochromator. Used for debugging. 
*
* %E
******************************************************************************/
DEFINE COMPONENT Monochromator_bent
DEFINITION PARAMETERS ()
SETTING PARAMETERS (zwidth = 0.2,
					yheight = 0.1,
					xthickness = 0.0005,
					radius_x = 2,
					string plane_of_reflection = "Si111",
					angle_to_cut_horizontal = 0,
					angle_to_cut_vertical = 0,
					mosaicity = 30,
					domainthickness = 10,
					temperature = 0,
					int verbose = 0)
OUTPUT PARAMETERS ()
// Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) 

SHARE
%{
	#include <string.h>

// #TODO: Implement for no mosaicity

////////////////////////////
// Mathematical Functions //
////////////////////////////

	// Function to return sign of a double
	double sign(double x){
		if (x > 0) return 1;
		if (x < 0) return -1;
		if (x == 0.0) return 0;
	}

	// Function to return a value squared
	double square(double x){
		return x*x;
	}

	// Function to return a random point on a gaussian 
	// with variance sigma and average at 0
	double gauss_0(double sigma){
		double u1, u2;
		u1 = rand01();
		u2 = rand01();
		double r = sqrt(-2 * log(u1));
		double theta = 2 * M_PI * u2;
		return sigma * r * cos(theta);
	}

	// The following two function returns, respectively, the Gaussian cumulative distribution function,
	// And the inverse gaussian cumulative distribution function. The latter is a numeric approximation
	// that could be optimized, but not neccisarily any need for it
	double normalCDF(double value) {
		return 0.5 * erfc(-value * M_SQRT1_2);
	}

	double inverse_of_normal_cdf(double p){
		if (p <= 0 || p >= 1) return sign(p)*6;

		double mu = 0;
		double sigma = 1;
		double r, val;
		double q = p - 0.5;

		if (abs(q) <= .425) {
			r = .180625 - q * q;
			val =
				q * (((((((r * 2509.0809287301226727 +
					33430.575583588128105) * r + 67265.770927008700853) * r +
					45921.953931549871457) * r + 13731.693765509461125) * r +
					1971.5909503065514427) * r + 133.14166789178437745) * r +
					3.387132872796366608)
				/ (((((((r * 5226.495278852854561 +
					28729.085735721942674) * r + 39307.89580009271061) * r +
					21213.794301586595867) * r + 5394.1960214247511077) * r +
					687.1870074920579083) * r + 42.313330701600911252) * r + 1);
		}
		else {
			if (q > 0) {
				r = 1 - p;
			}
			else {
				r = p;
			}

			r = sqrt(-log(r));

			if (r <= 5) 
			{
				r += -1.6;
				val = (((((((r * 7.7454501427834140764e-4 +
					.0227238449892691845833) * r + .24178072517745061177) *
					r + 1.27045825245236838258) * r +
					3.64784832476320460504) * r + 5.7694972214606914055) *
					r + 4.6303378461565452959) * r +
					1.42343711074968357734)
					/ (((((((r *
						1.05075007164441684324e-9 + 5.475938084995344946e-4) *
						r + .0151986665636164571966) * r +
						.14810397642748007459) * r + .68976733498510000455) *
						r + 1.6763848301838038494) * r +
						2.05319162663775882187) * r + 1);
			}
			else { /* very close to  0 or 1 */
				r += -5;
				val = (((((((r * 2.01033439929228813265e-7 +
					2.71155556874348757815e-5) * r +
					.0012426609473880784386) * r + .026532189526576123093) *
					r + .29656057182850489123) * r +
					1.7848265399172913358) * r + 5.4637849111641143699) *
					r + 6.6579046435011037772)
					/ (((((((r *
						2.04426310338993978564e-15 + 1.4215117583164458887e-7) *
						r + 1.8463183175100546818e-5) * r +
						7.868691311456132591e-4) * r + .0148753612908506148525)
						* r + .13692988092273580531) * r +
						.59983220655588793769) * r + 1);
			}

			if (q < 0.0) {
				val = -val;
			}
		}

		return mu + sigma * val;
	}
	// Integral needed for debye factor #TODO: Deeper explaination is needed here.
	double calculate_phi_integral(double x){
		// Asymptotic approximation
		if (x > 5) return PI * PI / 6 - exp(-x)/(x+1);
		double z = 1 + x/(exp(x)-1);
		double dx = x/100;
		double ksi;
		for (int i = 2; i <= 100; i++) {
			ksi = (i-1)*dx;
			switch (i%2){
				case 1:
					z = z + 4 * ksi/(exp(ksi)-1);
					break;
				case 0:
					z = z + 2 * ksi/(exp(ksi)-1);
					break;
			}
		}
		return z*dx/3;
	}

//////////////////////////////////////////////
// Structures for neutron and monochromator //
//////////////////////////////////////////////

	// Neutron values to save throughout the simulation
	struct neutron_values {
								// **Values from McStas, and calculated values related to this**								
		double r[3]; 			// Position at a given time during the simulation
		double v[3]; 			// velocity of neutron
		double v_size; 			// speed
		double l; 				// De Broglie wavelength of neutron
		double E; 				// energy of neutron
		double ki[3]; 			// Incoming wavevector
		double ki_size; 		// size of incoming wavevector

								// **Final wavevector, used to update the final speed**
		double kf[3]; 			// outgoing wavevector
		double kf_size; 		// size of outgoing wavevector
		double Bragg_angle;		// Bragg angle of scattering
		
								// **Calcualted scattering vector, see Saroun eq. 2 & 4**
		double Gr[3]; 			// Total scattering vector 
		double Gr_size;			// Size of scattering vector
		double Grad_G[3];		// Gradient component of scattering vector
		double Grad_G_size;		// Size of gradient component
		double perp_to_Gk[3];	// Vector perpendicular to G and ki
		double perp_size;		// Normalizing factor for perpendicular vector
		double gamma_0;			// Mosaicity in perpendicular direction
		double Ggamma[3];		// Perpendicular mosaicity
		double eps;				// Mosaicity in plane with G and ki
		double eps_zero;		// 0th order expansion of epsilon
		double beta;			// 1st order expansion of epsilon with respect to path travelled through crystal

								// **Path, time and probability of neutron through monochromator, see Saroun eq. 5 & 8**
		double path; 			// Length of the path the neutron follows
		double max_tau;			// Maximal possible time through crystal path
		double entry_time; 		// Time to start of crystal
		double exit_time; 		// Time to end of crystal (if not scattered)
		double tau[5];			// Time traveled each reflection. 
		double P[5];			// Probability of each reflection
		int scatter_count;	// Number of reflections

		int direction;			// Direction travelling (1 if towards monochromator, -1 if away)
	};		

	// Monochromator Values to save throughout the simulation
	struct monochromator_values{
													// **Set by user**
		double length, height, thickness;			// Dimensions of Monochromator
		double mos;									// Mosaicity
		int type;									// Value to define if flat, bent, and/or mosaic
		double radius_horizontal;					// Radius of curvature
		double temperature_mono;					// Temperature of monochromator
		double domain_thickness;					// Thickness of crystal domains

													// **Defined by Material, from RESTRAX**
		double Debye_Waller_factor;					// Debye Waller Factor for reflectivity
		double lattice_spacing;						// Lattice Spacing
		double Maier_Leibnitz_reflectivity;			// Maier Leibnitz Reflectivity							
		double poisson_ratio;						// Poisson ratio for curvature of material
		double bound_atom_scattering_cross_section;	// Scattering cross section - bound						
		double absorption_for_1AA_Neutrons;			// Scattering cross section - absportion for 1Ã…						
		double incoherent_scattering_cross_section;	// Scattering cross section - incoherent								
		double volume;								// Unit cell volume	
		double Constant_from_Freund_paper;			// Constant from Freund paper for different materials as monochroamtors						
		double debye_temperature;					// Debye Temperature				
		double atomic_number;						// Atomic number			
		double B0;									// Debye-Waller factor at 0 K
		double BT;									// Debye-Waller factor at set temperature
		double single_phonon_absorption;			// Scattering cross section - absportion for single phonon					
		double multiple_phonon_absorption;			// Scattering cross section - absportion for multiple phonon											
		double nuclear_capture_absorption;			// Scattering cross section - absportion for nuclear capture											

													// **Scattering vector cosntants**
		double G_size_zero;							// Scattering vector for flat monochromator
		double G0[3];								// Scattering vector tilted by off-cut of material
		double perp_G[3];							// Perpendicular to G0 and ki
		double lattice_spacing_gradient_field[3][3];// Gradient for scattering vector (curvature dependent)						
		double max_angle;							// Check if inside monochromator
		double min_angle;							// Check if inside monochromator	
	};

///////////////////////////////
// Crystal Plane information //
///////////////////////////////

	// All information about which crystal is being simulated.
	// Most of this information is used to calculate the attenuation and curvature effects.
	// Additional crystals cann be added if one wants, but information must be available for 
	// these materials.

	// Enumerated planes
	enum crystal_plane {Cu111, Cu200, Cu220, Cu311, Cu400, Cu331, Cu420, Cu440, Ge111, Ge220, Ge311,
				Ge400, Ge331, Ge422, Ge511, Ge533, Ge711, Ge551, Si111, Si220, Si311, Si400, Si331, 
				Si422, Si333, Si511, Si440, Si711, Si551, Be10, Be100, Be102, Be103, Be110, Be112, Be200, 
				Be00_2, Be10_1, PG00_2,PG00_4,PG00_6, Fe110, HS111,HS222,HS111star,Di111,Di220, Di311, Di400, 
				Di331, Di422, Di333, Di511, Di440};

	// An array containing all the possible strings that will be accepted if given as an 
	// argument to the parameter plane_of_reflection 
	const char* crystal_planeStrings[] = {
		"Cu111", "Cu200", "Cu220", "Cu311", "Cu400", "Cu331", "Cu420", "Cu440", "Ge111", "Ge220", "Ge311",
				"Ge400", "Ge331", "Ge422", "Ge511", "Ge533", "Ge711", "Ge551", "Si111", "Si220", "Si311", "Si400", "Si331", 
				"Si422", "Si333", "Si511", "Si440", "Si711", "Si551"," Be10", "Be100", "Be102", "Be103", "Be110", "Be112", "Be200", 
				"Be00_2", "Be10_1", "PG00_2","PG00_4","PG00_6", "Fe110", "HS111","HS222","HS111star","Di111","Di220", "Di311", "Di400", 
				"Di331", "Di422", "Di333", "Di511", "Di440"};

	// Function to convert a string to an enum value
	enum crystal_plane stringToEnum(const char* plane) {
		for (int i = 0; i < sizeof(crystal_planeStrings) / sizeof(crystal_planeStrings[0]); ++i) {
			if (strcmp(plane, crystal_planeStrings[i]) == 0) {
				return (enum crystal_plane)i;
			}
		}
	}

	/* Crystal table for perfect crystal bent monochromator
		Table copied from SIMRES, current url: https://github.com/saroun/simres
		Contents: dhkl, QML,sigmab,sigmaa,V0,A,thetaD,C2,poi
		dhkl ... Lattice spacing of crystal plane.
		QML = 4*PI*(F*dhkl/V0)**2 [ A^-1 cm^-1]
		sigmab ... bound-atom scattering cross-section [barn]
		sigmaa ... absorption for 1A neutrons [barn*A^-1]
		sigmai ... incoherent scattering cross-section [barn]
		V0 .... volume [A^3]/atom
		A  .... atomic number
		thetaD .... Debye temperature (K)
		C2 .... constant from the Freund's paper  [A^-2 eV^-1]
		poi .... Poisson elastic constant */
	double crystal_table[56][10] = {{ 2.087063,  0.23391E+00 ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 1.80745 , 0.17544E+00  ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 1.27806 , 0.87718E-01  ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 1.089933,  0.63795E-01 ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 0.903725,  0.43859E-01 ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 0.829315,  0.36934E-01 ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 0.808316,  0.35087E-01 ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 0.63903 , 0.21930E-01  ,7.485,  2.094,  0.55,	11.81,  63.54,  315,  12.00,  0.30000E+00},
								{ 3.26665 , 0.87700E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.15450E+00},
								{ 2.00041 , 0.65760E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.30000E+00},
								{ 1.70595 , 0.23920E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.15430E+00},
								{ 1.41450 , 0.32880E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27300E+00},
								{ 1.29803 , 0.13850E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.15430E+00},
								{ 1.15493 , 0.21925E-01  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27270E+00},
								{ 1.08888 , 0.97400E-02  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27270E+00},
								{ 0.86284 , 0.61200E-02  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27270E+00},
								{ 0.79228 , 0.51588E-02  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27270E+00},
								{ 0.79228 , 0.51600E-02  ,8.42 , 1.216,  0.18,  22.63,  72.6,  290,  9.0,  0.27270E+00},
								{ 3.13536 , 0.25970E-01  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.18080E+00},
								{ 1.92001 , 0.19480E-01  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.30000E+00},
								{ 1.63739 , 0.70800E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 1.35765 , 0.97400E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 1.24587 , 0.41000E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.18080E+00},
								{ 1.10852 , 0.64930E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 1.04512 , 0.28900E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 1.04512 , 0.28900E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 0.96000 , 0.48700E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 0.76044 , 0.15277E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 0.76044 , 0.15277E-02  ,2.18 , 0.0889,	0.0,  20.02,  28.09,  420,  6.36,  0.28000E+00},
								{ 1.97956 , 0.11361      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.30000E+00},
								{ 1.97956 , 0.11361      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 1.32857 , 0.05117      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 1.02290 , 0.091        ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 1.14290 , 0.15147      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 0.96363 , 0.10768      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 0.98978 , 0.0284       ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.28000E+00},
								{ 1.79215 , 0.37245      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.30000E+00},
								{ 1.73285 , 0.26116      ,7.62579,  0.00422655,	0.002,  8.10926,  9.012,  1100,  7.62,  0.30000E+00},
								{ 3.35500 , 0.79500E+00  ,5.555,  0.0019,	0.0,  8.80,  12.01,  1050,  20.00,  0.30000E+00},
								{ 1.67750 , 0.18000E+00  ,5.555,  0.0019,	0.0,  8.80,  12.01,  1050,  20.00,  0.30000E+00},
								{ 1.11830 , 0.08833E+00  ,5.555,  0.0019,	0.0,  8.80,  12.01,  1050,  20.00,  0.30000E+00},
								{ 2.02660 , 0.34031E+00  ,11.43,  2.53,	0.4 , 11.75 , 55.85,  411,  10.67 , 0.30000E+00},
								{ 3.43500 , 0.11020E+00  ,1.79,  2.88,	0.55,  13.16,  48.0,  300,  12.00 , 0.30000E+00},
								{ 1.71750 , 0.13130E+00  ,1.79,  2.88,	0.55,  13.16,  48.0,  300,  12.00 , 0.30000E+00},
								{ 3.43500 , 0.55100E-01  ,1.79,  2.88,	0.55,  13.16,  48.0,  300,  12.00 , 0.30000E+00},
								{ 2.05929 , 0.36606      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 1.26105 , 0.27455      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 1.07543 , 0.09984      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.89170 , 0.13727      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.81828 , 0.0578       ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.72807 , 0.09152      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.68643 , 0.04067      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.68643 , 0.04067      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.63053 , 0.06864      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00},
								{ 0.63053 , 0.06864      ,5.55449  ,0.00194444,	0.0,  5.67213,  12.01,  1860,  3.00,  0.30000E+00}
	};

//////////////////////
// Testing function //
//////////////////////

	// Function to test what neutron status is throughout the simulation 
	void print_neutron_state(struct neutron_values* neutron){
		printf("Neutron state:\nki %g, %g, %g\nkf %g, %g, %g\nv %g, %g, %g\nr %g, %g, %g\nG %g, %g, %g\nki size %g, kf size %g, v size %g, wavelength %g, energy %g, Gr %g\n\n", 
			neutron->ki[0], neutron->ki[1], neutron->ki[2],
			neutron->kf[0], neutron->kf[1], neutron->kf[2],
			neutron->v[0], neutron->v[1], neutron->v[2],
			neutron->r[0], neutron->r[1], neutron->r[2],
			neutron->Gr[0], neutron->Gr[1], neutron->Gr[2],
			neutron->ki_size, neutron->kf_size, neutron->v_size, neutron->l, neutron->E, neutron->Gr_size
			);
	};

///////////////////////
// Neutron Functions //
///////////////////////
	// Set neutron values for calculation
	void set_neutron_values(
		struct neutron_values* neutron,
		double x, double y, double z,
		double vx, double vy, double vz){
			neutron->r[0] = x;
			neutron->r[1] = y;
			neutron->r[2] = z;
			neutron->v[0] = vx;
			neutron->v[1] = vy;
			neutron->v[2] = vz;
			neutron->v_size = 0;
			neutron->ki_size = 0;
			neutron->kf_size = 0;
			for (int i =0; i<3; i++){ 
				neutron->ki[i] = neutron->v[i]*V2K;
				neutron->ki_size += square(neutron->ki[i]);
				neutron->v_size += square(neutron->v[i]);
				neutron->kf_size += square(neutron->kf[i]);
			}        
			neutron->v_size = sqrt(neutron->v_size);
			neutron->ki_size = sqrt(neutron->ki_size);
			neutron->kf_size = sqrt(neutron->kf_size);
			neutron->l = 3956/neutron->v_size;// Wavelength in Angstrom
			neutron->E = square(neutron->v_size/437); // Energy in meV
	};

	// Find intersection points with monochromator.
	// It is an integer to check for edge effects.
	void calc_intersection(struct monochromator_values* monochromator, struct neutron_values* neutron){
		double translated_x;
		double inner_t0;
		double inner_t1;
		double outer_t0;
		double outer_t1;
		
		// Translate neutron to coordinates of center of radius of curvature
		if ((monochromator->type == 0 )||( monochromator->type == 2)){
			translated_x = neutron->r[0]-1000000000-monochromator->thickness/2;
		} else {
			translated_x = neutron->r[0]-monochromator->radius_horizontal-monochromator->thickness/2;
		}

		// Checks intersection for inner radius
		cylinder_intersect(&inner_t0,&inner_t1,
							translated_x,neutron->r[1],neutron->r[2],
							neutron->v[0],neutron->v[1],neutron->v[2],
							monochromator->radius_horizontal,
							monochromator->height);

		// Checks intersection for outer radius
		cylinder_intersect(&outer_t0,&outer_t1,
							translated_x,neutron->r[1],neutron->r[2],
							neutron->v[0],neutron->v[1],neutron->v[2],
							monochromator->radius_horizontal+monochromator->thickness,
							monochromator->height);
		
		// Defines which time to take. Will always scatter from the curvature furthest away,
		// so no "inverted monochromators". This also means the monochromators HAVE to be pointing towards
		// way the neutrons are coming. 
		if (neutron->direction == 1){
			if (neutron->scatter_count > 0){
				if (outer_t1 > 0){
					neutron->exit_time = outer_t0 > outer_t1 ? outer_t0 : outer_t1;
				} else {
					neutron->exit_time = 0;
				}
			} else {
				neutron->entry_time = inner_t0 > inner_t1 ? inner_t0 : inner_t1;
				neutron->exit_time = outer_t0 > outer_t1 ? outer_t0 : outer_t1;
			}
		}
		else {
			if ((inner_t0 > 0)){
				neutron->entry_time = inner_t0 < inner_t1 ? inner_t0 : inner_t1;
			} else {
				neutron->entry_time = 0;
			}
		}
	}

	// Calculate scattering vector G using Saroun eq. 3
	void calculate_G(struct monochromator_values* monochromator, struct neutron_values* neutron){
		neutron->Gr_size = 0;
		double normalize = 0;
		// Curvature effect calculations
		for (int i=0; i<3; i++){
			neutron->Gr[i] = monochromator->G0[i];
			neutron->Gr_size += square(neutron->Gr[i]);
			for (int j=0; j<3; j++){
				neutron->Gr[i] += monochromator->lattice_spacing_gradient_field[i][j]*neutron->r[j];
			}
			neutron->Grad_G[i] = (neutron->Gr[i] - monochromator->G0[i])*neutron->direction;
			neutron->Gr[i] *= neutron->direction;
		}
		// Set size for scattering vector
		neutron->Gr_size = sqrt(neutron->Gr_size);


		// Define gamma vector, which has to be out of the ki-G plane
		vec_prod(neutron->perp_to_Gk[0],neutron->perp_to_Gk[1],neutron->perp_to_Gk[2],neutron->ki[0],neutron->ki[1],neutron->ki[2],neutron->Gr[0],neutron->Gr[1],neutron->Gr[2]);
		neutron->perp_size = sqrt(square(neutron->perp_to_Gk[0])+square(neutron->perp_to_Gk[1])+square(neutron->perp_to_Gk[2]));
		
		// Normal distribution of mosaicity
		if ((monochromator->type==2) || (monochromator->type==3)){
			neutron->gamma_0 = gauss_0(monochromator->mos);
		} else {
			neutron->gamma_0 = 0;
		}
		// Calculate Bragg angle from G and ki  
		neutron->Bragg_angle = PI - acos((neutron->ki[0]*monochromator->perp_G[0]+
									neutron->ki[1]*monochromator->perp_G[1]+
									neutron->ki[2]*monochromator->perp_G[2])/
									(neutron->ki_size));

		// Claculate Gamma vector
		for (int i=0;i<3;i++){
			neutron->perp_to_Gk[i] /= neutron->perp_size;
			neutron->Ggamma[i] = neutron->Gr_size*neutron->perp_to_Gk[i]*neutron->gamma_0;
			neutron->Gr[i] += neutron->Ggamma[i];	
			normalize += square(neutron->Gr[i]);					   
		}
		normalize = sqrt(normalize);
		neutron->Gr[0] *= neutron->Gr_size/normalize;
		neutron->Gr[1] *= neutron->Gr_size/normalize;
		neutron->Gr[2] *= neutron->Gr_size/normalize;
	}

	// Calculate epsilon zero and beta fron Saroun Eq. 4
	void calculate_epszero_and_beta(struct monochromator_values* monochromator, struct neutron_values* neutron){
		double G[3];
		double temp_eps0 = 0;
		double temp_beta = 0;
		G[0] = (neutron->ki[0]+neutron->Gr[0]*neutron->direction);
		G[1] = (neutron->ki[1]+neutron->Gr[1]*neutron->direction);
		G[2] = (neutron->ki[2]+neutron->Gr[2]*neutron->direction);
		
		temp_eps0 = (square(G[1])+square(G[0])+square(G[2]) - square(neutron->ki_size));
		double denominator = 2*neutron->Gr_size*neutron->ki_size*cos(neutron->Bragg_angle);
		neutron->eps_zero = -temp_eps0/denominator*neutron->direction;
		
		double Gk[3];
		for (int i=0;i<3;i++){
			Gk[i] = 0;
			for (int j=0;j<3;j++){
				Gk[i] += monochromator->lattice_spacing_gradient_field[i][j]*neutron->ki[j]*neutron->direction;
			}	
		}
		G[0] = (neutron->ki[0]+monochromator->G0[0]*neutron->direction+neutron->Ggamma[0]);
		G[1] = (neutron->ki[1]+monochromator->G0[1]*neutron->direction+neutron->Ggamma[1]);
		G[2] = (neutron->ki[2]+monochromator->G0[2]*neutron->direction+neutron->Ggamma[2]);
		
		temp_beta = (G[0])*Gk[0]
					+ (G[1])*Gk[1]
					+ (G[2])*Gk[2];
		neutron->beta = -temp_beta/(denominator*neutron->ki_size/2);
	}

	// B0 and BT are values used for the Debye factor #TODO: Explain equation
	void calculate_B0_and_BT(struct monochromator_values *monochromator){
		double x;
		monochromator->B0 = 2872.556/monochromator->atomic_number
								/monochromator->debye_temperature;
		
		if (monochromator->temperature_mono>0.1) x = monochromator->debye_temperature/monochromator->temperature_mono;
		else x =monochromator->debye_temperature/0.1;
		double phi = calculate_phi_integral(x);

		monochromator->BT = 4 * monochromator->B0 * phi / square(x);
	}

	// #TODO: Find citation for this equation and check if it works
	// Calculate the kinematic reflectivity of material
	double calculate_kinematic_reflectivity(struct monochromator_values* monochromator, 
											struct neutron_values* neutron){
		double sine_of_bragg_angle = neutron->l/2/monochromator->lattice_spacing;
		double cosine_of_bragg_angle = sqrt(1-square(sine_of_bragg_angle));
		double extinction_length =  monochromator->lattice_spacing/neutron->l*sqrt(4*PI/monochromator->Maier_Leibnitz_reflectivity*100);
		
		// Kinenatic reflectivity = QML*DHKL*sin(theta_B)**2/PI/cos(theta_B)
		double kinematic_reflectivity = monochromator->Maier_Leibnitz_reflectivity;
		kinematic_reflectivity *= monochromator->lattice_spacing;
		kinematic_reflectivity *= square(sine_of_bragg_angle);
		kinematic_reflectivity *= 1/PI/cosine_of_bragg_angle;
		kinematic_reflectivity *= monochromator->Debye_Waller_factor;
		// Primary extinction factor, using the approximation in G.E Bacon and R.D. Lowde, Acta Cryst. (1948). 1, 303
		kinematic_reflectivity *= tanh(monochromator->domain_thickness/extinction_length)/monochromator->domain_thickness*extinction_length;
		return kinematic_reflectivity;
	}

	// Calculate time of flight and probability through crystal
	void calculate_tau_and_prob(struct monochromator_values* monochromator, struct neutron_values* neutron, int i){
		double Q = calculate_kinematic_reflectivity(monochromator, neutron);

		// First calculate probability of scattering
		if ((monochromator->type==2 )|| (monochromator->type==3)){
			neutron->P[i] = 1;
			double arg1 = (neutron->eps_zero+neutron->beta*neutron->max_tau*neutron->v_size)/monochromator->mos;
			neutron->P[i] = (1-exp(-(Q/(fabs(neutron->beta*neutron->ki_size)))*(normalCDF(arg1)-normalCDF(neutron->eps_zero/monochromator->mos))));

			// Second calculate time travelled through crystal
			neutron->tau[i] = normalCDF(neutron->eps_zero/monochromator->mos);
			neutron->tau[i]-= ((fabs(neutron->beta*neutron->ki_size))/Q)*log(1-rand01());
			neutron->tau[i] = inverse_of_normal_cdf(neutron->tau[i]);
			neutron->tau[i]*= monochromator->mos/(neutron->ki_size*neutron->beta);
			neutron->tau[i]-= neutron->eps_zero/(neutron->ki_size*neutron->beta);
			neutron->tau[i]*= neutron->ki_size/neutron->v_size;	
		} else {
			neutron->P[i] = 1- exp(-Q/(fabs(neutron->beta*neutron->ki_size)));
			neutron->tau[i] = -neutron->eps_zero/(neutron->ki_size*neutron->beta);
			neutron->tau[i] *= neutron->ki_size/neutron->v_size;
		}
	}

	// Update to final kf
	void calculate_kf(struct monochromator_values* monochromator, struct neutron_values* neutron, int j){

		// Calculate in G-ki plane mosaicity (Saroun eq. 4)
		double epsilon[3];
		double epsilon_size;
		double eps;
		eps = neutron->eps_zero+neutron->tau[j]*neutron->beta*neutron->v_size;
		// 	("%.13g, %.13g, %.13g, %.13g\n", neutron->eps_zero, neutron->beta, eps, neutron->P[j]);
		vec_prod(epsilon[0],epsilon[1],epsilon[2],neutron->perp_to_Gk[0],neutron->perp_to_Gk[1],neutron->perp_to_Gk[2],neutron->Gr[0],neutron->Gr[1],neutron->Gr[2]);
		epsilon_size = sqrt(square(epsilon[0])+square(epsilon[1])+square(epsilon[2]));
		neutron->kf_size = 0;

		// Calculate G
		double normalize = 0;
		for (int i=0;i<3;i++){
			neutron->Gr[i] = monochromator->G0[i];
			for (int k=0;k<3;k++){
				neutron->Gr[i] += monochromator->lattice_spacing_gradient_field[i][k]*neutron->r[k];
			}
			neutron->Gr[i] += neutron->direction*(neutron->Gr_size*eps*epsilon[i]/epsilon_size)+neutron->Ggamma[i];
			normalize += square(neutron->Gr[i]);
		}
		
		normalize = sqrt(normalize);
		for (int i=0;i<3;i++){
			neutron->Gr[i] *= neutron->Gr_size/normalize;
		}

		// Calculate final scattering vector (Saroun eq. 3)
		for (int i=0;i<3;i++){
			neutron->kf[i] = neutron->ki[i]+neutron->Gr[i];
			neutron->kf_size += square(neutron->kf[i]);
		}
		neutron->kf_size = sqrt(neutron->kf_size);

		// Noramlize for Bragg condition
		for (int i=0;i<3;i++){
			neutron->kf[i] *= neutron->ki_size/neutron->kf_size;
		}
	}

	// Reflect neutron
	void reflect_neutron(struct neutron_values* neutron, double* vx, double* vy, double* vz){
			*vx = (neutron->kf[0])*K2V;
			*vy = (neutron->kf[1])*K2V;
			*vz = (neutron->kf[2])*K2V;
	}

	// Attenuation coefficient calculation 
	// Cited from Andreas K. Freund 20. December 1982
	double calculate_attenuation_coefficient(struct monochromator_values* monochromator,
										struct neutron_values* neutron){
		double E = square(neutron->v_size)*VS2E; // Neutron energy in meV
		// Get factor for single phonon cross section
		
		double Bernoulli_sequence[31] = {1,-0.5,0.166667,0,-0.033333,0,0.0238095,0,-0.033333,
										0,0.0757576,0,-0.253114,0,1.16667,0,-7.09216,0,54.9712,
										0,-529.124,0,6192.12,0,-86580.3,0,1.42551717e6,0,-2.7298231e7,
										0,6.01580874e8};
		double x;
		if (monochromator->temperature_mono - 0.1 <= 0){
			x = monochromator->debye_temperature/0.1;
		}
		else{
			x = monochromator->debye_temperature/monochromator->temperature_mono;
		} 
		double R, Ifact, Xn;
		if (x<6){
			R = 0;
			Ifact = 1;
			Xn = 1/x;
			for (int i=0; i<30; i++){
				R += Bernoulli_sequence[i]*Xn/Ifact/(i + 2.5);
				Xn *= x;
				Ifact *= i + 1;
			}
		}
		else R = 3.3/sqrt(x*x*x*x*x*x*x);

		// Define boltzmann_constant in units of (meV/K)
		double boltzmann_constant = 0.08617333262;
		double DWMF =  1-exp(-(monochromator->B0+monochromator->BT)*monochromator->Constant_from_Freund_paper*E/1000);
		// Set the cross sections, as written in freunds paper
		monochromator->nuclear_capture_absorption = monochromator->incoherent_scattering_cross_section
													+monochromator->absorption_for_1AA_Neutrons*neutron->l;

		monochromator->multiple_phonon_absorption = monochromator->bound_atom_scattering_cross_section
											*square(monochromator->atomic_number/(monochromator->atomic_number + 1))
											*DWMF;

		monochromator->single_phonon_absorption = 3*monochromator->bound_atom_scattering_cross_section/monochromator->atomic_number
											* sqrt(boltzmann_constant * monochromator->debye_temperature/E) * R;

		double attenuation_coefficient =  (monochromator->nuclear_capture_absorption
										+ monochromator->single_phonon_absorption
										+ monochromator->multiple_phonon_absorption)
										/monochromator->volume * 100; // *100 to change to per mm?
		return attenuation_coefficient;
	}

	void prop_half(struct monochromator_values* monochromator, struct neutron_values* neutron){
		// Calculate intersection with monochromator
		neutron->r[0] += neutron->v[0]*(neutron->exit_time-neutron->entry_time)/2;
		neutron->r[1] += neutron->v[1]*(neutron->exit_time-neutron->entry_time)/2;
		neutron->r[2] += neutron->v[2]*(neutron->exit_time-neutron->entry_time)/2;
	}

%}


DECLARE
%{
	// Create the neutron and monochromator structures
	struct neutron_values neutron;
	struct monochromator_values monochromator;

	int non_scattered;
	int scattered;
	int non_hit;
%}

INITIALIZE
%{
	non_scattered = 0;
	scattered = 0;
	non_hit = 0;
/////////////////////
// ERROR FUNCTIONS //
/////////////////////
	if (radius_x < 0)
		exit(printf("G_approach_bent_perfect_crystal: %s: incorrect radius_x=%g\n", NAME_CURRENT_COMP, radius_x));
	if (xthickness <= 0)
		exit(printf("G_approach_bent_perfect_crystal: %s: invalid monochromator xthickness=%g\n", NAME_CURRENT_COMP, xthickness));
	if (zwidth <= 0)
		exit(printf("G_approach_bent_perfect_crystal: %s: invalid monochromator zwidth=%g\n", NAME_CURRENT_COMP, zwidth));

//////////////////////////
// Monochromator values //
//////////////////////////

	// Which type of monochromator
		if (!radius_x && !mosaicity) {
			monochromator.type = 0;
		} else if (radius_x && !mosaicity) {
			monochromator.type = 1;
		} else if (!radius_x && mosaicity) {
			monochromator.type = 2;
		} else if (radius_x && mosaicity) {
			monochromator.type = 3;
		}
	
		// Define monochromator angles
	if ((monochromator.type == 0) || (monochromator.type == 2)){
		monochromator.max_angle = PI;
		monochromator.min_angle = PI;
	} else {
		monochromator.max_angle = atan(zwidth/(2*radius_x)) + PI;
		monochromator.min_angle = -atan(zwidth/(2*radius_x)) + PI;
	}
	
	// Read the designated plane of reflection, for use in the monochromator
		enum crystal_plane plane = stringToEnum(&plane_of_reflection);
	
	// Set monochromator values
		monochromator.length = zwidth;
		monochromator.height = yheight;
		monochromator.thickness = xthickness;
		monochromator.radius_horizontal = radius_x;
		monochromator.domain_thickness = domainthickness;
		monochromator.lattice_spacing = crystal_table[plane][0];
		monochromator.Maier_Leibnitz_reflectivity = crystal_table[plane][1]*100; // Convert to SI and Angstrom
		monochromator.bound_atom_scattering_cross_section = crystal_table[plane][2];
		monochromator.absorption_for_1AA_Neutrons = crystal_table[plane][3];
		monochromator.incoherent_scattering_cross_section = crystal_table[plane][4];
		monochromator.volume = crystal_table[plane][5];
		monochromator.atomic_number = crystal_table[plane][6];
		monochromator.debye_temperature = crystal_table[plane][7];
		monochromator.Constant_from_Freund_paper = crystal_table[plane][8];
		monochromator.poisson_ratio = crystal_table[plane][9];
		monochromator.temperature_mono = 300;

	// Calculate Debye Waller Factor
		calculate_B0_and_BT(&monochromator);
		monochromator.Debye_Waller_factor = exp(-(monochromator.B0 + monochromator.BT)/2/square(monochromator.lattice_spacing));

	// Set mosaicity
		if ((monochromator.type == 2) || (monochromator.type == 3)){
			//Input mosaicity is in arc min. Convert to radians, then to sigma from FWHM
			monochromator.mos = mosaicity*MIN2RAD*FWHM2RMS; 
		}
		else {
			monochromator.mos = 0; 
		}   

	// Set scattering vector
		angle_to_cut_horizontal *= DEG2RAD;
		angle_to_cut_vertical *= DEG2RAD;

		monochromator.G_size_zero = 2*PI/monochromator.lattice_spacing;
		
		monochromator.G0[0] = monochromator.G_size_zero*cos(angle_to_cut_horizontal)*cos(angle_to_cut_vertical);
		monochromator.G0[1] = monochromator.G_size_zero*sin(angle_to_cut_vertical);
		monochromator.G0[2] = monochromator.G_size_zero*sin(angle_to_cut_horizontal)*cos(angle_to_cut_vertical);

		monochromator.perp_G[0] = sin(angle_to_cut_horizontal)*cos(angle_to_cut_vertical);
		monochromator.perp_G[1] = sin(angle_to_cut_vertical);
		monochromator.perp_G[2] = -cos(angle_to_cut_horizontal)*cos(angle_to_cut_vertical);

	// Initialize lattice_spacing_gradient_field 
		if ((monochromator.type == 0 )|| (monochromator.type == 2)){
			monochromator.lattice_spacing_gradient_field[0][0] = 0;
			monochromator.lattice_spacing_gradient_field[0][1] = 0;
			monochromator.lattice_spacing_gradient_field[0][2] = 0;
			monochromator.lattice_spacing_gradient_field[1][0] = 0;
			monochromator.lattice_spacing_gradient_field[1][1] = 0;
			monochromator.lattice_spacing_gradient_field[1][2] = 0;
			monochromator.lattice_spacing_gradient_field[2][0] = 0;
			monochromator.lattice_spacing_gradient_field[2][1] = 0;
			monochromator.lattice_spacing_gradient_field[2][2] = 0;
		} else{
			double curvature = 1/radius_x;
			monochromator.lattice_spacing_gradient_field[0][0] = -monochromator.poisson_ratio*cos(angle_to_cut_horizontal)*monochromator.G_size_zero*curvature;
			monochromator.lattice_spacing_gradient_field[0][1] = 0;
			monochromator.lattice_spacing_gradient_field[0][2] = sin(angle_to_cut_horizontal)*monochromator.G_size_zero*curvature;
			monochromator.lattice_spacing_gradient_field[1][0] = 0;
			monochromator.lattice_spacing_gradient_field[1][1] = 0;
			monochromator.lattice_spacing_gradient_field[1][2] = 0;
			monochromator.lattice_spacing_gradient_field[2][0] = sin(angle_to_cut_horizontal)*monochromator.G_size_zero*curvature;
			monochromator.lattice_spacing_gradient_field[2][1] = 0;
			monochromator.lattice_spacing_gradient_field[2][2] = -cos(angle_to_cut_horizontal)*monochromator.G_size_zero*curvature;
		}
%}

TRACE
%{
	// Set the neutron values for the new neutron and direction
	set_neutron_values(&neutron,x,y,z,vx,vy,vz);
	neutron.direction = 1;
	neutron.scatter_count = 0;
	// Check weight is not 0
	double weight_init = p;
	double k_initial = neutron.ki_size;
									 
	if (weight_init == 0.0){
		ABSORB;
	}
	
	// Find the intersection 
	calc_intersection(&monochromator,&neutron);
																					 
																						

	// Propogate neutron and reset the neutron values
	PROP_DT(neutron.entry_time);
	set_neutron_values(&neutron,x,y,z,vx,vy,vz);
	double angle_on_inner_cylinder;
	// Is the neutron in the area of the monochromator?
	if ((monochromator.type== 1) || (monochromator.type == 3)){
		angle_on_inner_cylinder = PI - atan(neutron.r[2]/monochromator.radius_horizontal);
	} else {
		angle_on_inner_cylinder = PI;
	}
	if ((monochromator.max_angle >= angle_on_inner_cylinder) && (angle_on_inner_cylinder >= monochromator.min_angle)){
		// If yes, then it can possibly be scattered

		// Set the maximal tau for first scattering
		neutron.max_tau = neutron.exit_time-neutron.entry_time;
		neutron.path = 0;
		// Allow for up to 5 scattering indicents to limit computation time
		for (int i = 0; i < 1; i++){	
			// Walk step is repeated for each step here.
			// First calculate scattering vector, eps_zero and beta with random vertical mosaicity
			//prop_half(&monochromator,&neutron);
			calculate_G(&monochromator,&neutron);
			calculate_epszero_and_beta(&monochromator,&neutron);
			// Calculate probability of scattering and time of scattering
			calculate_tau_and_prob(&monochromator,&neutron,i);
			// Will the neutron scatter inside the crystal (between entry and exit times) 
			// and is the probability not INCREDIBLY low (limit calculations)
			if ((neutron.tau[i] < neutron.max_tau) && (neutron.tau[i] > 0)){ 
				
				// Reflect neutron
				// Propogate to scattering point
				scattered++;
				PROP_DT(neutron.tau[i]);
				set_neutron_values(&neutron,x,y,z,vx,vy,vz);

				// Update probability
				p *= neutron.P[i];
				if (p == 0.0) ABSORB;
				neutron.scatter_count += 1;
				
				

				// Update kf and scatter
				calculate_kf(&monochromator,&neutron,i);
				if (i==0){SCATTER;}

				// Reflect neutron and set new variables for next scattering
				reflect_neutron(&neutron, &vx, &vy, &vz);
				set_neutron_values(&neutron,x,y,z,vx,vy,vz);

				neutron.path += neutron.tau[i]*neutron.v_size;
			}else {
				non_scattered++;
				// Travel through the entire path and do not update any speeds
				p *= 1-neutron.P[i];
				neutron.path += sign(neutron.max_tau)*neutron.max_tau*neutron.v_size;
				// Break out of loop, such that no more scattering can occur
				break;
			}
			// Update direction 
			neutron.direction *= -1;

			// Calculate new intersection points
			calc_intersection(&monochromator,&neutron);
			
			if (neutron.direction == -1){
				neutron.max_tau = neutron.entry_time;
				
			} else {
				neutron.max_tau = neutron.exit_time;
			}
			
		
		}
		// Attenuate probability for path
		double attenuation_coefficient = calculate_attenuation_coefficient(&monochromator, &neutron);
		p *= exp(-attenuation_coefficient*neutron.path);
	}else {
		// If not, let it pass through the component
		/* restore neutron state when no interaction */
		non_hit++;
		RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
	}
	
	// # Done
%}

FINALLY
%{
	double beta = neutron.beta;
	double eps_zero = neutron.eps_zero;
	int scatter_count = scattered;
%}

MCDISPLAY
%{
	double x_edges[2];
	double z_edges[2];
	double y_edges[2];
	double angle_range = monochromator.max_angle - monochromator.min_angle;
	if (radius_x == 0){
		radius_x = 10000000;
	}

	x_edges[0] = radius_x - (radius_x-xthickness/2)*cos(angle_range/2);
	x_edges[1] = radius_x - (radius_x+xthickness/2)*cos(angle_range/2);

	z_edges[0] = (radius_x-xthickness/2)*sin(angle_range/2);
	z_edges[1] = (radius_x+xthickness/2)*sin(angle_range/2);

	y_edges[0] = -yheight/2;
	y_edges[1] = yheight/2;

	double temp_x[4], temp_z[4];
	temp_x[0] = x_edges[0];
	temp_x[2] = x_edges[1];
	temp_z[0] = - z_edges[0];
	temp_z[2] = - z_edges[1];

	int n = 20;
	double delta_theta = angle_range/(n-1);
	for (int i=1; i<n; i++){
		// Inner upper
		temp_x[1] = radius_x - (radius_x-xthickness/2)*cos(angle_range/2-delta_theta*i);
		temp_x[3] = radius_x - (radius_x+xthickness/2)*cos(angle_range/2-delta_theta*i);
		temp_z[1] = -(radius_x-xthickness/2)*sin(angle_range/2-delta_theta*i);
		temp_z[3] = -(radius_x+xthickness/2)*sin(angle_range/2-delta_theta*i);

		line(temp_x[0],y_edges[0],temp_z[0],
			temp_x[1],y_edges[0],temp_z[1]);
		line(temp_x[0],y_edges[1],temp_z[0],
			temp_x[1],y_edges[1],temp_z[1]);
		line(temp_x[2],y_edges[0],temp_z[2],
			temp_x[3],y_edges[0],temp_z[3]);
		line(temp_x[2],y_edges[1],temp_z[2],
			temp_x[3],y_edges[1],temp_z[3]);

		// New starting values
		temp_x[0] = temp_x[1];
		temp_x[2] = temp_x[3];
		temp_z[0] = temp_z[1];
		temp_z[2] = temp_z[3];

	}

	line(x_edges[0],y_edges[0],z_edges[0],
		x_edges[0],y_edges[1],z_edges[0]);
	line(x_edges[1],y_edges[0],z_edges[1],
		x_edges[1],y_edges[1],z_edges[1]);
	line(x_edges[0],y_edges[0],-z_edges[0],
		x_edges[0],y_edges[1],-z_edges[0]);
	line(x_edges[1],y_edges[0],-z_edges[1],
		x_edges[1],y_edges[1],-z_edges[1]);

	line(x_edges[0],y_edges[0],z_edges[0],
		x_edges[1],y_edges[0],z_edges[1]);
	line(x_edges[0],y_edges[1],z_edges[0],
		x_edges[1],y_edges[1],z_edges[1]);
	line(x_edges[0],y_edges[0],-z_edges[0],
		x_edges[1],y_edges[0],-z_edges[1]);
	line(x_edges[0],y_edges[1],-z_edges[0],
		x_edges[1],y_edges[1],-z_edges[1]);
%}

END
